<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>reveal.js</title>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <!-- Theme used for syntax highlighting of code-->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!-- Printing and PDF exports-->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
      
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Vertical-Slice Architecture</h1>
        </section>
        <section>
          <h3>Scope of this presentation</h3><img class="stretch" src="img/scope-1.svg">
        </section>
        <section>
          <h3>Scope of this presentation</h3><img class="stretch" src="img/scope-2.svg">
        </section>
        <section>
          <h3>Why talk about architecture on this level?</h3>
        </section>
        <section>
          <h3>Beginning of a greenfield project</h3>
          <ul>
            <li class="fragment">With small amount of code 'everything' looks good</li>
            <li class="fragment">Requirements are changing</li>
            <li class="fragment">Temptation to just reuse template from last project</li>
          </ul>
        </section>
        <section>
          <h3>One year later</h3>
          <ul>
            <li class="fragment">Maintainability issues</li>
            <li class="fragment">Extensibility issues</li>
            <li class="fragment">Performance issues</li>
            <li class="fragment">Bugs</li>
            <li class="fragment">Developer unhappiness</li>
          </ul>
        </section>
        <section>
          <h3>It's too late to change it</h3>
          <ul>
            <li class="fragment">It would cost too much</li>
            <li class="fragment">Heavy risk of regressions</li>
          </ul>
        </section>
        <section>
          <h3>Which software architecture is most common?</h3>
        </section>
        <section>
          <h3>Big ball of mud</h3>
          <p class="fragment">Common in practice due to business pressures, developer turnover and code entropy</p>
        </section>
        <section>
          <h3>1. Choosing right architecture from beginning is very important</h3>
        </section>
        <section>
          <h2>Common patterns</h2>
        </section>
        <section>
          <h3>Basic architecture</h3>
          <ul>
            <li class="fragment">Also known as "Everything in a Controller"</li>
            <li class="fragment">Often used as a starting point</li>
            <li class="fragment">Popular among students / junior devs</li>
          </ul>
        </section>
        <section>
          <h3>Basic architecture</h3><img class="stretch" src="img/basic-arch.svg">
        </section>
        <section>
          <h3>Basic architecture</h3>
          <pre><code data-trim data-noescape>﻿using BasicArchitecture.Data;
using BasicArchitecture.Data.Entities;
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;
using System.Linq;

namespace BasicArchitecture.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        private readonly DataContext _dataContext;

        public UsersController(DataContext dataContext)
        {
            _dataContext = dataContext;
        }

        [HttpGet]
        public ActionResult<IEnumerable<UserEntity>> Get()
        {
            return _dataContext.Users.ToList();
        }
    }
}
</code></pre>
        </section>
        <section>
          <h3>Later you add</h3>
          <ul>
            <li class="fragment">Request validation</li>
            <li class="fragment">Authorization rules</li>
            <li class="fragment">Complex business logic</li>
            <li class="fragment">Mapping between DB model and API model</li>
            <li class="fragment">...other stuff</li>
          </ul>
        </section>
        <section>
          <h3>Controller now have 1K+ lines of code</h3>
          <p class="fragment">Unmaintainable big ball of mud</p>
        </section>
        <section>
          <h3>This architecture doesn't scale with added code.</h3>
        </section>
        <section>
          <h3>Types of scalability</h3>
          <ul>
            <li class="fragment">Usage Scalability
              <ul>
                <li>number of requests</li>
              </ul>
            </li>
            <li class="fragment">Scalability over period
              <ul>
                <li>size of stored data</li>
              </ul>
            </li>
            <li class="fragment">Code scalability
              <ul>
                <li>amount of code</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>2. Think about code scalability</h3>
          <ul>
            <li class="fragment">Single responsibility principle</li>
            <li class="fragment">Open–closed principle</li>
          </ul>
        </section>
        <section>
          <h3>Domain-Driven Design</h3>
        </section>
        <section>
          <h3>Building blocks</h3>
          <ul>
            <li class="fragment">Entity</li>
            <li class="fragment">Value object</li>
            <li class="fragment">Aggregate</li>
            <li class="fragment">Domain Event</li>
            <li class="fragment">Service</li>
            <li class="fragment">Repository</li>
            <li class="fragment">Factory</li>
          </ul>
        </section>
        <section>
          <h3>HTTP is a REQUEST / RESPONSE protocol</h3>
          <ul>
            <li class="fragment">Model instance doesn't exists between requests</li>
            <li class="fragment">It's a temporary representation of state based on request and data in database</li>
          </ul>
        </section>
        <section>
          <h3>Layers in Domain-Driven Design service</h3>
          <ul>
            <li class="fragment">API (REST/JSON)</li>
            <li class="fragment">Domain (model)</li>
            <li class="fragment">Data (store)</li>
          </ul>
        </section>
        <section><img class="stretch" src="img/ddd-layers.png"></section>
        <section>
          <h3>It's good right?</h3>
          <p class="fragment">...well, it has some drawbacks</p>
        </section>
        <section>
          <h3>DDD pitfalls: Mapping</h3>
          <ul>
            <li class="fragment">Mapping from DB schema to domain entities</li>
            <li class="fragment">Mapping from domain entities to API contract models</li>
          </ul>
        </section>
        <section>
          <h3>DDD pitfalls: Mapping</h3>
          <p>Error prone, boilerplate code without business value</p>
        </section>
        <section>
          <h3>DDD pitfalls: Repository</h3>
          <ul>
            <li class="fragment">Abstraction of abstraction (DbContext)</li>
            <li class="fragment">Fat repository - aggregate of all data access of entity
              <ul>
                <li class="fragment">Methods used only once</li>
                <li class="fragment">Reuse of method which doesn't fit use-case</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>DDD pitfalls: Performance</h3>
          <ul>
            <li class="fragment">Developers don't think about database</li>
            <ul>
              <li class="fragment">Query more data then needed</li>
              <li class="fragment">Multiple queries with manual join</li>
            </ul>
          </ul>
        </section>
        <section>
          <h3>DDD pitfalls: Anemic Domain Model</h3>
          <ul>
            <li>"Domain models" without behavior</li>
            <li>Class with bunch of getters and setters</li>
            <li>Anti-pattern</li>
          </ul>
        </section>
        <section>
          <h3>DDD pitfalls: Adding new feature</h3>
          <ul>
            <li class="fragment">Modify API layer</li>
            <li class="fragment">Modify Domain layer</li>
            <li class="fragment">Modify Data layer</li>
            <li class="fragment">don't forget about mappers :)</li>
          </ul>
        </section>
        <section>
          <h3>DDD pitfalls: Adding new feature</h3><img class="stretch" src="img/feature-slice.svg">
        </section>
        <section>
          <p>
            Microsoft recommends that it be applied only to complex domains where the model
            and the linguistic processes provide clear benefits in the communication of complex information,
            and in the formulation of a common understanding of the domain.
          </p>
        </section>
        <section>
          <h3>tl;dr:</h3>
          <p>Worth only for cases where business complexity is bigger issue than DDD abstractions.</p>
        </section>
        <section>
          <h3>3. KISS - keep it simple, stupid</h3>
        </section>
      </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
      dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
      ],
      backgroundTransition: 'none',
      history: true,
      transition: 'none',
      });
    </script>
  </body>
</html>